<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">
<link href="style.css" type="text/css" rel="stylesheet">
<title>PSLLW/PSLLD/PSLLQ—Shift Packed Data Left Logical </title></head>
<body>
<h1>PSLLW/PSLLD/PSLLQ—Shift Packed Data Left Logical</h1>
<table>
<tr>
<th>Description</th>
<th>CPUID Feature Flag</th>
<th>Opcode/Instruction</th>
<th>Op/En</th>
<th>64/32 bit Mode Support</th></tr>
<tr>
<td>Shift words in <em>mm</em> left <em>mm/m64</em> while shifting in 0s.</td>
<td>MMX</td>
<td>
<p>0F F1 /<em>r</em><sup>1</sup></p>
<p>PSLLW <em>mm, mm/m64</em></p></td>
<td>RM</td>
<td>V/V</td></tr>
<tr>
<td>Shift words in <em>xmm1</em> left by <em>xmm2/m128</em> while shifting in 0s.</td>
<td>SSE2</td>
<td>
<p>66 0F F1 /<em>r</em></p>
<p>PSLLW <em>xmm1</em>, <em>xmm2/m128</em></p></td>
<td>RM</td>
<td>V/V</td></tr>
<tr>
<td>Shift words in <em>mm</em> left by <em>imm8</em> while shifting in 0s.</td>
<td>MMX</td>
<td>
<p>0F 71 /6 ib</p>
<p>PSLLW <em>mm1</em>, <em>imm8</em></p></td>
<td>MI</td>
<td>V/V</td></tr>
<tr>
<td>Shift words in <em>xmm1</em> left by <em>imm8</em> while shifting in 0s.</td>
<td>SSE2</td>
<td>
<p>66 0F 71 /6 ib</p>
<p>PSLLW <em>xmm1</em>, <em>imm8</em></p></td>
<td>MI</td>
<td>V/V</td></tr>
<tr>
<td>Shift doublewords in <em>mm</em> left by <em>mm/m64</em> while shifting in 0s.</td>
<td>MMX</td>
<td>
<p>0F F2 /<em>r</em><sup>1</sup></p>
<p>PSLLD<em> mm, mm/m64</em></p></td>
<td>RM</td>
<td>V/V</td></tr>
<tr>
<td>Shift doublewords in <em>xmm1</em> left by <em>xmm2/m128 </em>while shifting in 0s.</td>
<td>SSE2</td>
<td>
<p>66 0F F2 /<em>r</em></p>
<p>PSLLD <em>xmm1</em>, <em>xmm2/m128</em></p></td>
<td>RM</td>
<td>V/V</td></tr>
<tr>
<td>Shift doublewords in <em>mm</em> left by <em>imm8</em> while shifting in 0s.</td>
<td>MMX</td>
<td>
<p>0F 72 /6 ib<sup>1</sup></p>
<p>PSLLD <em>mm, imm8</em></p></td>
<td>MI</td>
<td>V/V</td></tr>
<tr>
<td>Shift doublewords in <em>xmm1</em> left by <em>imm8</em> while shifting in 0s.</td>
<td>SSE2</td>
<td>
<p>66 0F 72 /6 ib</p>
<p>PSLLD <em>xmm1</em>, <em>imm8</em></p></td>
<td>MI</td>
<td>V/V</td></tr>
<tr>
<td>Shift quadword in <em>mm</em> left by <em>mm/m64 </em>while shifting in 0s.</td>
<td>MMX</td>
<td>
<p>0F F3 /<em>r</em><sup>1</sup></p>
<p>PSLLQ <em>mm, mm/m64</em></p></td>
<td>RM</td>
<td>V/V</td></tr>
<tr>
<td>Shift quadwords in <em>xmm1</em> left by <em>xmm2/m128 </em>while shifting in 0s.</td>
<td>SSE2</td>
<td>
<p>66 0F F3 /<em>r</em></p>
<p>PSLLQ <em>xmm1</em>, <em>xmm2/m128</em></p></td>
<td>RM</td>
<td>V/V</td></tr>
<tr>
<td>Shift quadword in <em>mm</em> left by <em>imm8</em> while shifting in 0s.</td>
<td>MMX</td>
<td>
<p>0F 73 /6 ib<sup>1</sup></p>
<p>PSLLQ <em>mm, imm8</em></p></td>
<td>MI</td>
<td>V/V</td></tr>
<tr>
<td>Shift quadwords in <em>xmm1</em> left by <em>imm8</em> while shifting in 0s.</td>
<td>SSE2</td>
<td>
<p>66 0F 73 /6 ib</p>
<p>PSLLQ <em>xmm1</em>, <em>imm8</em></p></td>
<td>MI</td>
<td>V/V</td></tr>
<tr>
<td>Shift words in <em>xmm2</em> left by amount specified in <em>xmm3/m128 </em>while shifting in 0s.</td>
<td>AVX</td>
<td>
<p>VEX.NDS.128.66.0F.WIG F1 /r</p>
<p>VPSLLW <em>xmm1, xmm2, xmm3/m128</em></p></td>
<td>RVM</td>
<td>V/V</td></tr>
<tr>
<td>Shift words in <em>xmm2</em> left by <em>imm8</em> while shifting in 0s.</td>
<td>AVX</td>
<td>
<p>VEX.NDD.128.66.0F.WIG 71 /6 ib</p>
<p>VPSLLW <em>xmm1, xmm2, imm8</em></p></td>
<td>VMI</td>
<td>V/V</td></tr>
<tr>
<td>Shift doublewords in <em>xmm2</em> left by amount specified in <em>xmm3/m128</em> while shifting in 0s.</td>
<td>AVX</td>
<td>
<p>VEX.NDS.128.66.0F.WIG F2 /r</p>
<p>VPSLLD <em>xmm1, xmm2, xmm3/m128</em></p></td>
<td>RVM</td>
<td>V/V</td></tr>
<tr>
<td>Shift doublewords in <em>xmm2 </em>left by<em> imm8</em> while shifting in 0s.</td>
<td>AVX</td>
<td>
<p>VEX.NDD.128.66.0F.WIG 72 /6 ib</p>
<p>VPSLLD <em>xmm1, xmm2, imm8</em></p></td>
<td>VMI</td>
<td>V/V</td></tr>
<tr>
<td>Shift quadwords in <em>xmm2</em> left by amount specified in <em>xmm3/m128</em> while shifting in 0s.</td>
<td>AVX</td>
<td>
<p>VEX.NDS.128.66.0F.WIG F3 /r</p>
<p>VPSLLQ <em>xmm1, xmm2, xmm3/m128</em></p></td>
<td>RVM</td>
<td>V/V</td></tr>
<tr>
<td>Shift quadwords in <em>xmm2</em> left by<em> imm8</em> while shifting in 0s.</td>
<td>AVX</td>
<td>
<p>VEX.NDD.128.66.0F.WIG 73 /6 ib</p>
<p>VPSLLQ <em>xmm1, xmm2, imm8</em></p></td>
<td>VMI</td>
<td>V/V</td></tr>
<tr>
<td>Shift words in <em>ymm2</em> left by amount specified in <em>xmm3/m128</em> while shifting in 0s.</td>
<td>AVX2</td>
<td>
<p>VEX.NDS.256.66.0F.WIG F1 /r</p>
<p>VPSLLW <em>ymm1, ymm2, xmm3/m128</em></p></td>
<td>RVM</td>
<td>V/V</td></tr>
<tr>
<td>Shift words in <em>ymm2</em> left by <em>imm8</em> while shifting in 0s.</td>
<td>AVX2</td>
<td>
<p>VEX.NDD.256.66.0F.WIG 71 /6 ib</p>
<p>VPSLLW <em>ymm1, ymm2, imm8</em></p></td>
<td>VMI</td>
<td>V/V</td></tr></table>
<table>
<tr>
<td>
<p>VEX.NDS.256.66.0F.WIG F2 /r</p>
<p>VPSLLD <em>ymm1, ymm2, xmm3/m128</em></p></td>
<td>RVM</td>
<td>V/V</td>
<td>AVX2</td>
<td>Shift doublewords in <em>ymm2</em> left by amount specified in <em>xmm3/m128</em> while shifting in 0s.</td></tr>
<tr>
<td>
<p>VEX.NDD.256.66.0F.WIG 72 /6 ib</p>
<p>VPSLLD <em>ymm1, ymm2, imm8</em></p></td>
<td>VMI</td>
<td>V/V</td>
<td>AVX2</td>
<td>Shift doublewords in <em>ymm2</em> left by<em> imm8 </em>while shifting in 0s.</td></tr>
<tr>
<td>
<p>VEX.NDS.256.66.0F.WIG F3 /r</p>
<p>VPSLLQ <em>ymm1, ymm2, xmm3/m128</em></p></td>
<td>RVM</td>
<td>V/V</td>
<td>AVX2</td>
<td>Shift quadwords in <em>ymm2</em> left by amount specified in <em>xmm3/m128</em> while shifting in 0s.</td></tr>
<tr>
<td>
<p>VEX.NDD.256.66.0F.WIG 73 /6 ib</p>
<p>VPSLLQ <em>ymm1, ymm2, imm8</em></p></td>
<td>VMI</td>
<td>V/V</td>
<td>AVX2</td>
<td>Shift quadwords in <em>ymm2</em> left by <em>imm8</em> while shifting in 0s.</td></tr>
<tr>
<td>
<p>EVEX.NDS.128.66.0F.WIG F1 /r</p>
<p>VPSLLW xmm1 {k1}{z}, xmm2, xmm3/m128</p></td>
<td>M128</td>
<td>V/V</td>
<td>AVX512VL AVX512BW</td>
<td>Shift words in xmm2 left by amount specified in xmm3/m128 while shifting in 0s using writemask k1.</td></tr>
<tr>
<td>
<p>EVEX.NDS.256.66.0F.WIG F1 /r</p>
<p>VPSLLW ymm1 {k1}{z}, ymm2, xmm3/m128</p>
<p>EVEX.NDS.512.66.0F.WIG F1 /r</p>
<p>VPSLLW zmm1 {k1}{z}, zmm2, xmm3/m128</p></td>
<td>
<p>M128</p>
<p>M128</p></td>
<td>
<p>V/V</p>
<p>V/V</p></td>
<td>
<p>AVX512VL AVX512BW</p>
<p>AVX512BW Shift words in zmm2 left by amount specified in</p></td>
<td>
<p>Shift words in ymm2 left by amount specified in xmm3/m128 while shifting in 0s using writemask k1.</p>
<p>xmm3/m128 while shifting in 0s using writemask k1.</p></td></tr>
<tr>
<td>
<p>EVEX.NDD.128.66.0F.WIG 71 /6 ib</p>
<p>VPSLLW xmm1 {k1}{z}, xmm2/m128, imm8</p></td>
<td>FVMI</td>
<td>V/V</td>
<td>AVX512VL AVX512BW</td>
<td>Shift words in xmm2/m128 left by imm8 while shifting in 0s using writemask k1.</td></tr>
<tr>
<td>
<p>EVEX.NDD.256.66.0F.WIG 71 /6 ib</p>
<p>VPSLLW ymm1 {k1}{z}, ymm2/m256, imm8</p>
<p>EVEX.NDD.512.66.0F.WIG 71 /6 ib</p>
<p>VPSLLW zmm1 {k1}{z}, zmm2/m512, imm8</p></td>
<td>
<p>FVMI</p>
<p>FVMI</p></td>
<td>
<p>V/V</p>
<p>V/V</p></td>
<td>
<p>AVX512VL AVX512BW</p>
<p>AVX512BW Shift words in zmm2/m512 left by imm8 while</p></td>
<td>
<p>Shift words in ymm2/m256 left by imm8 while shifting in 0s using writemask k1.</p>
<p>shifting in 0 using writemask k1.</p></td></tr>
<tr>
<td>
<p>EVEX.NDS.128.66.0F.W0 F2 /r</p>
<p>VPSLLD xmm1 {k1}{z}, xmm2, xmm3/m128</p></td>
<td>M128</td>
<td>V/V</td>
<td>AVX512VL AVX512F</td>
<td>Shift doublewords in xmm2 left by amount specified in xmm3/m128 while shifting in 0s under writemask k1.</td></tr>
<tr>
<td>
<p>EVEX.NDS.256.66.0F.W0 F2 /r</p>
<p>VPSLLD ymm1 {k1}{z}, ymm2, xmm3/m128</p></td>
<td>M128</td>
<td>V/V</td>
<td>AVX512VL AVX512F</td>
<td>Shift doublewords in ymm2 left by amount specified in xmm3/m128 while shifting in 0s under writemask k1.</td></tr>
<tr>
<td>
<p>EVEX.NDS.512.66.0F.W0 F2 /r</p>
<p>VPSLLD zmm1 {k1}{z}, zmm2, xmm3/m128</p></td>
<td>M128</td>
<td>V/V</td>
<td>AVX512F</td>
<td>Shift doublewords in zmm2 left by amount specified in xmm3/m128 while shifting in 0s under writemask k1.</td></tr>
<tr>
<td>
<p>EVEX.NDD.128.66.0F.W0 72 /6 ib</p>
<p>VPSLLD xmm1 {k1}{z}, xmm2/m128/m32bcst, imm8</p></td>
<td>FVI</td>
<td>V/V</td>
<td>AVX512VL AVX512F</td>
<td>Shift doublewords in xmm2/m128/m32bcst left by imm8 while shifting in 0s using writemask k1.</td></tr>
<tr>
<td>
<p>EVEX.NDD.256.66.0F.W0 72 /6 ib</p>
<p>VPSLLD ymm1 {k1}{z}, ymm2/m256/m32bcst, imm8</p></td>
<td>FVI</td>
<td>V/V</td>
<td>AVX512VL AVX512F</td>
<td>Shift doublewords in ymm2/m256/m32bcst left by imm8 while shifting in 0s using writemask k1.</td></tr>
<tr>
<td>
<p>EVEX.NDD.512.66.0F.W0 72 /6 ib</p>
<p>VPSLLD zmm1 {k1}{z}, zmm2/m512/m32bcst, imm8</p></td>
<td>FVI</td>
<td>V/V</td>
<td>AVX512F</td>
<td>Shift doublewords in zmm2/m512/m32bcst left by imm8 while shifting in 0s using writemask k1.</td></tr>
<tr>
<td>
<p>EVEX.NDS.128.66.0F.W1 F3 /r</p>
<p>VPSLLQ xmm1 {k1}{z}, xmm2, xmm3/m128</p></td>
<td>M128</td>
<td>V/V</td>
<td>AVX512VL AVX512F</td>
<td>Shift quadwords in xmm2 left by amount specified in xmm3/m128 while shifting in 0s using writemask k1.</td></tr></table>
<table>
<tr>
<td>
<p>EVEX.NDS.256.66.0F.W1 F3 /r</p>
<p>VPSLLQ ymm1 {k1}{z}, ymm2, xmm3/m128</p></td>
<td>M128</td>
<td>V/V</td>
<td>AVX512VL AVX512F</td>
<td>Shift quadwords in ymm2 left by amount specified in xmm3/m128 while shifting in 0s using writemask k1.</td></tr>
<tr>
<td>
<p>EVEX.NDS.512.66.0F.W1 F3 /r</p>
<p>VPSLLQ zmm1 {k1}{z}, zmm2, xmm3/m128</p></td>
<td>M128</td>
<td>V/V</td>
<td>AVX512F</td>
<td>Shift quadwords in zmm2 left by amount specified in xmm3/m128 while shifting in 0s using writemask k1.</td></tr>
<tr>
<td>
<p>EVEX.NDD.128.66.0F.W1 73 /6 ib</p>
<p>VPSLLQ xmm1 {k1}{z}, xmm2/m128/m64bcst, imm8</p></td>
<td>FVI</td>
<td>V/V</td>
<td>AVX512VL AVX512F</td>
<td>Shift quadwords in xmm2/m128/m64bcst left by imm8 while shifting in 0s using writemask k1.</td></tr>
<tr>
<td>
<p>EVEX.NDD.256.66.0F.W1 73 /6 ib</p>
<p>VPSLLQ ymm1 {k1}{z}, ymm2/m256/m64bcst, imm8</p></td>
<td>FVI</td>
<td>V/V</td>
<td>AVX512VL AVX512F</td>
<td>Shift quadwords in ymm2/m256/m64bcst left by imm8 while shifting in 0s using writemask k1.</td></tr>
<tr>
<td>
<p>EVEX.NDD.512.66.0F.W1 73 /6 ib</p>
<p>VPSLLQ zmm1 {k1}{z}, zmm2/m512/m64bcst, imm8</p></td>
<td>FVI</td>
<td>V/V</td>
<td>AVX512F</td>
<td>Shift quadwords in zmm2/m512/m64bcst left by imm8 while shifting in 0s using writemask k1.</td></tr></table>
<p>NOTES:</p>
<p>1. See note in Section 2.4, “AVX and SSE Instruction Exception Specification” in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2A</em> and Section 22.25.3, “Exception Conditions of Legacy SIMD Instructions Operating on MMX Registers” in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A</em>.</p>
<h3>Instruction Operand Encoding</h3>
<table>
<tr>
<td>Op/En</td>
<td>Operand 1</td>
<td>Operand 2</td>
<td>Operand 3</td>
<td>Operand 4</td></tr>
<tr>
<td>RM</td>
<td>ModRM:reg (r, w)</td>
<td>ModRM:r/m (r)</td>
<td>NA</td>
<td>NA</td></tr>
<tr>
<td>MI</td>
<td>ModRM:r/m (r, w)</td>
<td>imm8</td>
<td>NA</td>
<td>NA</td></tr>
<tr>
<td>RVM</td>
<td>ModRM:reg (w)</td>
<td>VEX.vvvv (r)</td>
<td>ModRM:r/m (r)</td>
<td>NA</td></tr>
<tr>
<td>VMI</td>
<td>VEX.vvvv (w)</td>
<td>ModRM:r/m (r)</td>
<td>imm8</td>
<td>NA</td></tr>
<tr>
<td>FVMI</td>
<td>EVEX.vvvv (w)</td>
<td>ModRM:r/m (R)</td>
<td>Imm8</td>
<td>NA</td></tr>
<tr>
<td>FVI</td>
<td>EVEX.vvvv (w)</td>
<td>ModRM:r/m (R)</td>
<td>Imm8</td>
<td>NA</td></tr>
<tr>
<td>M128</td>
<td>ModRM:reg (w)</td>
<td>VEX.vvvv (r)</td>
<td>ModRM:r/m (r)</td>
<td>NA</td></tr></table>
<h2>Description</h2>
<p>Shifts the bits in the individual data elements (words, doublewords, or quadword) in the destination operand (first operand) to the left by the number of bits specified in the count operand (second operand). As the bits in the data elements are shifted left, the empty low-order bits are cleared (set to 0). If the value specified by the count operand is greater than 15 (for words), 31 (for doublewords), or 63 (for a quadword), then the destination operand is set to all 0s. Figure 4-17 gives an example of shifting words in a 64-bit operand.</p>
<svg width="568.799985" viewBox="112.380000 768034.020000 379.199990 87.599995" height="131.3999925">
<text y="768052.306488" x="158.6999" style="font-size:7.991000pt" lengthAdjust="spacingAndGlyphs" textLength="30.9619286">Pre-Shift</text>
<text y="768056.386788" x="406.62" style="font-size:7.991000pt" lengthAdjust="spacingAndGlyphs" textLength="9.7833813">X0</text>
<text y="768060.586788" x="169.26" style="font-size:7.991000pt" lengthAdjust="spacingAndGlyphs" textLength="21.3263808">DEST</text>
<text y="768072.025388" x="162.06" style="font-size:6.960000pt" lengthAdjust="spacingAndGlyphs" textLength="27.928392">Shift Left</text>
<text y="768079.825388" x="161.46" style="font-size:6.960000pt" lengthAdjust="spacingAndGlyphs" textLength="28.5012">with Zero</text>
<text y="768087.625488" x="160.9199" style="font-size:6.960000pt" lengthAdjust="spacingAndGlyphs" textLength="29.379552">Extension</text>
<text y="768105.166188" x="153.8997" style="font-size:7.991000pt" lengthAdjust="spacingAndGlyphs" textLength="34.5634723">Post-Shift</text>
<text y="768113.146888" x="168.18" style="font-size:7.991000pt" lengthAdjust="spacingAndGlyphs" textLength="21.3263808">DEST</text>
<rect y="768044.64" x="193.38" style="fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;" height="18.0" width="62.88"></rect>
<rect y="768044.64" x="256.26" style="fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;" height="18.0" width="62.88"></rect>
<rect y="768044.64" x="319.14" style="fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;" height="18.0" width="62.88"></rect>
<rect y="768097.62" x="192.78" style="fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;" height="18.0" width="62.88"></rect>
<rect y="768097.62" x="381.48" style="fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;" height="18.0" width="62.88"></rect>
<rect y="768097.62" x="255.66" style="fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;" height="18.0" width="62.88"></rect>
<rect y="768097.62" x="318.54" style="fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;" height="18.0" width="62.94"></rect>
<path style="stroke:black" d="M193.140000,768044.400000 L193.140000,768062.640000 L193.620000,768062.640000 L193.620000,768044.400000 "></path>
<path style="stroke:black" d="M193.380000,768044.400000 L193.380000,768044.880000 L256.500000,768044.880000 L256.500000,768044.400000 "></path>
<path style="stroke:black" d="M256.020000,768044.400000 L256.020000,768062.640000 L256.500010,768062.640000 L256.500010,768044.400000 "></path>
<path style="stroke:black" d="M256.260000,768044.400000 L256.260000,768044.880000 L319.380000,768044.880000 L319.380000,768044.400000 "></path>
<path style="stroke:black" d="M318.900000,768044.400000 L318.900000,768062.640000 L319.380010,768062.640000 L319.380010,768044.400000 "></path>
<path style="stroke:black" d="M319.140000,768044.400000 L319.140000,768044.880000 L382.260000,768044.880000 L382.260000,768044.400000 "></path>
<path style="stroke:black" d="M381.780000,768044.400000 L381.780000,768062.640000 L382.260010,768062.640000 L382.260010,768044.400000 "></path>
<path style="stroke:black" d="M382.020000,768044.400000 L382.020000,768044.880000 L445.200000,768044.880000 L445.200000,768044.400000 "></path>
<path style="stroke:black" d="M256.020000,768044.640000 L256.020000,768062.880000 L256.500010,768062.880000 L256.500010,768044.640000 "></path>
<path style="stroke:black" d="M318.900000,768044.640000 L318.900000,768062.880000 L319.380010,768062.880000 L319.380010,768044.640000 "></path>
<path style="stroke:black" d="M381.780000,768044.640000 L381.780000,768062.880000 L382.260010,768062.880000 L382.260010,768044.640000 "></path>
<path style="stroke:black" d="M382.020000,768044.640000 L444.960000,768044.640000 L444.960000,768062.640000 L382.020000,768062.640000 "></path>
<path style="stroke:black" d="M444.720000,768044.640000 L444.720000,768062.880000 L445.200010,768062.880000 L445.200010,768044.640000 "></path>
<path style="stroke:black" d="M193.140000,768062.400000 L193.140000,768062.880000 L256.260000,768062.880000 L256.260000,768062.400000 "></path>
<path style="stroke:black" d="M256.020000,768062.400000 L256.020000,768062.880000 L319.140000,768062.880000 L319.140000,768062.400000 "></path>
<path style="stroke:black" d="M318.900000,768062.400000 L318.900000,768062.880000 L382.020000,768062.880000 L382.020000,768062.400000 "></path>
<path style="stroke:black" d="M381.780000,768062.400000 L381.780000,768062.880000 L444.960000,768062.880000 L444.960000,768062.400000 "></path>
<path style="stroke:black" d="M300.720000,768062.760000 L300.720000,768077.700000 L301.200010,768077.700000 L301.200010,768062.760000 "></path>
<path style="stroke:black" d="M237.000000,768062.820000 L237.000000,768077.760000 L237.480000,768077.760000 L237.480000,768062.820000 "></path>
<path style="stroke:black" d="M419.220000,768062.820000 L419.220000,768077.760000 L419.700010,768077.760000 L419.700010,768062.820000 "></path>
<path style="stroke:black" d="M357.480000,768063.240000 L357.480000,768078.240000 L357.959980,768078.240000 L357.959980,768063.240000 "></path>
<path style="stroke:black" d="M275.040000,768077.220000 L275.040000,768077.700000 L300.960000,768077.700000 L300.960000,768077.220000 "></path>
<path style="stroke:black" d="M211.320000,768077.280000 L211.320000,768077.760000 L237.240000,768077.760000 L237.240000,768077.280000 "></path>
<path style="stroke:black" d="M393.480000,768077.280000 L393.480000,768077.760000 L419.460000,768077.760000 L419.460000,768077.280000 "></path>
<path style="stroke:black" d="M275.040000,768077.460000 L275.040000,768090.360000 L275.519980,768090.360000 L275.519980,768077.460000 "></path>
<path style="stroke:black" d="M211.320000,768077.520000 L211.320000,768090.420000 L211.800010,768090.420000 L211.800010,768077.520000 "></path>
<path style="stroke:black" d="M393.480000,768077.520000 L393.480000,768090.480000 L393.959980,768090.480000 L393.959980,768077.520000 "></path>
<path style="stroke:black" d="M331.800000,768077.760000 L331.800000,768078.240000 L357.720000,768078.240000 L357.720000,768077.760000 "></path>
<path style="stroke:black" d="M331.800000,768078.000000 L331.800000,768090.900000 L332.279980,768090.900000 L332.279980,768078.000000 "></path>
<path style="stroke:black" d="M211.380000,768090.780000 L212.880000,768090.180000 L213.840000,768089.760000 L212.040000,768096.240000 L211.560000,768097.920000 L211.080000,768096.240000 L209.520000,768090.840000 L209.220000,768089.820000 L210.180000,768090.180000 L210.480000,768090.540000 L212.040000,768095.940000 L211.080000,768096.240000 L211.080000,768095.940000 L212.580000,768090.540000 L213.540000,768090.840000 L213.240000,768091.140000 L211.740000,768091.740000 "></path>
<path style="stroke:black" d="M275.100000,768090.720000 L276.600000,768090.180000 L277.560000,768089.760000 L277.260000,768090.840000 L275.760000,768096.180000 L275.280000,768097.800000 L274.800000,768096.180000 L273.240000,768090.840000 L272.940000,768089.820000 L273.900000,768090.180000 L274.200000,768090.540000 L275.760000,768095.880000 L274.800000,768096.180000 L274.800000,768095.880000 L276.300000,768090.540000 L277.260000,768090.840000 L276.960000,768091.140000 L275.460000,768091.680000 "></path>
<path style="stroke:black" d="M393.540000,768090.780000 L395.100000,768090.240000 L396.060000,768089.880000 L395.760000,768090.900000 L394.200000,768096.240000 L393.720000,768097.860000 L393.240000,768096.240000 L391.680000,768090.900000 L391.380000,768089.880000 L392.340000,768090.240000 L392.640000,768090.600000 L394.200000,768095.940000 L393.240000,768096.240000 L393.240000,768095.940000 L394.800000,768090.600000 L395.760000,768090.900000 L395.460000,768091.200000 L393.900000,768091.740000 "></path>
<path style="stroke:black" d="M275.040000,768090.120000 L275.040000,768091.200000 L275.519980,768091.200000 L275.519980,768090.120000 "></path>
<path style="stroke:black" d="M210.180000,768090.180000 L211.740000,768090.780000 L211.740000,768091.740000 L211.560000,768091.800000 L211.380000,768091.740000 L209.820000,768091.140000 "></path>
<path style="stroke:black" d="M211.320000,768090.180000 L211.320000,768091.260000 L211.800010,768091.260000 L211.800010,768090.180000 "></path>
<path style="stroke:black" d="M273.900000,768090.180000 L275.460000,768090.720000 L275.460000,768091.680000 L275.280000,768091.740000 L275.100000,768091.680000 L273.540000,768091.140000 "></path>
<path style="stroke:black" d="M331.860000,768091.200000 L333.360000,768090.660000 L334.320000,768090.240000 L332.520000,768096.720000 L332.040000,768098.400000 L331.560000,768096.720000 L330.000000,768091.320000 L329.700000,768090.300000 L330.660000,768090.660000 L330.960000,768091.020000 L332.520000,768096.420000 L331.560000,768096.720000 L331.560000,768096.420000 L333.060000,768091.020000 L334.020000,768091.320000 L333.720000,768091.620000 L332.220000,768092.160000 "></path>
<path style="stroke:black" d="M392.340000,768090.240000 L393.900000,768090.780000 L393.900000,768091.740000 L393.720000,768091.800000 L393.540000,768091.740000 L391.980000,768091.200000 "></path>
<path style="stroke:black" d="M393.480000,768090.240000 L393.480000,768091.260000 L393.959980,768091.260000 L393.959980,768090.240000 "></path>
<path style="stroke:black" d="M211.560000,768091.260000 L213.060000,768090.660000 L211.560000,768096.060000 L210.000000,768090.660000 "></path>
<path style="stroke:black" d="M275.280000,768091.200000 L276.780000,768090.660000 L275.280000,768096.000000 L273.720000,768090.660000 "></path>
<path style="stroke:black" d="M330.660000,768090.660000 L332.220000,768091.200000 L332.220000,768092.160000 L332.040000,768092.220000 L331.860000,768092.160000 L330.300000,768091.620000 "></path>
<path style="stroke:black" d="M331.800000,768090.660000 L331.800000,768091.680000 L332.279980,768091.680000 L332.279980,768090.660000 "></path>
<path style="stroke:black" d="M393.720000,768091.260000 L395.280000,768090.720000 L393.720000,768096.060000 L392.160000,768090.720000 "></path>
<path style="stroke:black" d="M332.040000,768091.680000 L333.540000,768091.140000 L332.040000,768096.540000 L330.480000,768091.140000 "></path>
<path style="stroke:black" d="M192.780000,768097.379990 L192.780000,768097.860000 L255.900000,768097.860000 L255.900000,768097.379990 "></path>
<path style="stroke:black" d="M255.660000,768097.379990 L255.660000,768097.860000 L318.780000,768097.860000 L318.780000,768097.379990 "></path>
<path style="stroke:black" d="M318.540000,768097.379990 L318.540000,768097.860000 L381.720000,768097.860000 L381.720000,768097.379990 "></path>
<path style="stroke:black" d="M381.480000,768097.379990 L381.480000,768097.860000 L444.600000,768097.860000 L444.600000,768097.379990 "></path>
<path style="stroke:black" d="M192.540000,768097.380000 L192.540000,768115.620000 L193.020010,768115.620000 L193.020010,768097.380000 "></path>
<path style="stroke:black" d="M255.420000,768097.380000 L255.420000,768115.620000 L255.900000,768115.620000 L255.900000,768097.380000 "></path>
<path style="stroke:black" d="M318.300000,768097.380000 L318.300000,768115.620000 L318.780010,768115.620000 L318.780010,768097.380000 "></path>
<path style="stroke:black" d="M381.240000,768097.380000 L381.240000,768115.620000 L381.719980,768115.620000 L381.719980,768097.380000 "></path>
<path style="stroke:black" d="M255.420000,768097.620000 L255.420000,768115.860000 L255.900000,768115.860000 L255.900000,768097.620000 "></path>
<path style="stroke:black" d="M318.300000,768097.620000 L318.300000,768115.860000 L318.780010,768115.860000 L318.780010,768097.620000 "></path>
<path style="stroke:black" d="M381.240000,768097.620000 L381.240000,768115.860000 L381.719980,768115.860000 L381.719980,768097.620000 "></path>
<path style="stroke:black" d="M444.120000,768097.620000 L444.120000,768115.860000 L444.599980,768115.860000 L444.599980,768097.620000 "></path>
<path style="stroke:black" d="M192.540000,768115.379990 L192.540000,768115.860000 L255.660000,768115.860000 L255.660000,768115.379990 "></path>
<path style="stroke:black" d="M255.420000,768115.379990 L255.420000,768115.860000 L318.540000,768115.860000 L318.540000,768115.379990 "></path>
<path style="stroke:black" d="M318.300000,768115.379990 L318.300000,768115.860000 L381.480000,768115.860000 L381.480000,768115.379990 "></path>
<path style="stroke:black" d="M381.240000,768115.379990 L381.240000,768115.860000 L444.360000,768115.860000 L444.360000,768115.379990 "></path>
<text y="768056.387388" x="219.6011" style="font-size:7.991000pt" lengthAdjust="spacingAndGlyphs" textLength="9.7833813">X3</text>
<text y="768056.387388" x="283.3181376" style="font-size:7.991000pt" lengthAdjust="spacingAndGlyphs" textLength="9.7833813">X2</text>
<text y="768056.387388" x="344.3342172" style="font-size:7.991000pt" lengthAdjust="spacingAndGlyphs" textLength="9.7833813">X1</text>
<text y="768110.146888" x="197.5801" style="font-size:7.991000pt" lengthAdjust="spacingAndGlyphs" textLength="53.5966174">X3 &lt;&lt; COUNT</text>
<text y="768110.146288" x="385.2001" style="font-size:7.991000pt" lengthAdjust="spacingAndGlyphs" textLength="12.0008838">X0 &lt;&lt; COUNT</text>
<text y="768110.146888" x="261.3603" style="font-size:7.991000pt" lengthAdjust="spacingAndGlyphs" textLength="53.5964174">X2 &lt;&lt; COUNT</text>
<text y="768110.146888" x="324.6005" style="font-size:7.991000pt" lengthAdjust="spacingAndGlyphs" textLength="53.5962174">X1 &lt;&lt; COUNT</text></svg>
<h3>Figure 4-17.  PSLLW, PSLLD, and PSLLQ Instruction Operation Using 64-bit Operand</h3>
<p>The (V)PSLLW instruction shifts each of the words in the destination operand to the left by the number of bits spec-ified in the count operand; the (V)PSLLD instruction shifts each of the doublewords in the destination operand; and the (V)PSLLQ instruction shifts the quadword (or quadwords) in the destination operand.</p>
<p>In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p>
<p>Legacy SSE instructions 64-bit operand: The destination operand is an MMX technology register; the count operand can be either an MMX technology register or an 64-bit memory location.</p>
<p>128-bit Legacy SSE version: The destination and first source operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged. The count operand can be either an XMM register or a 128-bit memory location or an 8-bit immediate. If the count operand is a memory address, 128 bits are loaded but the upper 64 bits are ignored.</p>
<p>VEX.128 encoded version: The destination and first source operands are XMM registers. Bits (VLMAX-1:128) of the destination YMM register are zeroed. The count operand can be either an XMM register or a 128-bit memory loca-tion or an 8-bit immediate. If the count operand is a memory address, 128 bits are loaded but the upper 64 bits are ignored.</p>
<p>VEX.256 encoded version: The destination operand is a YMM register. The source operand is a YMM register or a memory location. The count operand can come either from an XMM register or a memory location or an 8-bit imme-diate. Bits (MAX_VL-1:256) of the corresponding ZMM register are zeroed.</p>
<p>EVEX encoded versions: The destination operand is a ZMM register updated according to the writemask. The count operand is either an 8-bit immediate (the immediate count version) or an 8-bit value from an XMM register or a memory location (the variable count version). For the immediate count version, the source operand (the second operand) can be a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location. For the variable count version, the first source operand (the second operand) is a ZMM register, the second source operand (the third operand, 8-bit variable count) can be an XMM register or a memory location.</p>
<p>Note: In VEX/EVEX encoded versions of shifts with an immediate count, vvvv of VEX/EVEX encode the destination register, and VEX.B/EVEX.B + ModRM.r/m encodes the source register.</p>
<p>Note: For shifts with an immediate count (VEX.128.66.0F 71-73 /6, or EVEX.128.66.0F 71-73 /6), VEX.vvvv/EVEX.vvvv encodes the destination register.</p>
<h2>Operation</h2>
<p><strong>PSLLW (with 64-bit operand)</strong></p>
<pre>    IF (COUNT &gt; 15)
    THEN
         DEST[64:0] ← 0000000000000000H;
    ELSE
         DEST[15:0] ← ZeroExtend(DEST[15:0] &lt;&lt; COUNT);
         (* Repeat shift operation for 2nd and 3rd words *)
         DEST[63:48] ← ZeroExtend(DEST[63:48] &lt;&lt; COUNT);
    FI;</pre>
<p><strong>PSLLD (with 64-bit operand)</strong></p>
<pre>    IF (COUNT &gt; 31)
    THEN
         DEST[64:0] ← 0000000000000000H;
    ELSE
         DEST[31:0] ← ZeroExtend(DEST[31:0] &lt;&lt; COUNT);
         DEST[63:32] ← ZeroExtend(DEST[63:32] &lt;&lt; COUNT);
    FI;</pre>
<p><strong>PSLLQ (with 64-bit operand)</strong></p>
<pre>    IF (COUNT &gt; 63)
    THEN
         DEST[64:0] ← 0000000000000000H;
    ELSE
         DEST ← ZeroExtend(DEST &lt;&lt; COUNT);
    FI;
LOGICAL_LEFT_SHIFT_WORDS(SRC, COUNT_SRC)
COUNT (cid:197)COUNT_SRC[63:0];
IF (COUNT &gt; 15)
THEN
    DEST[127:0] (cid:197)00000000000000000000000000000000H
ELSE
    DEST[15:0] (cid:197)ZeroExtend(SRC[15:0] &lt;&lt; COUNT);
    (* Repeat shift operation for 2nd through 7th words *)
    DEST[127:112] (cid:197)ZeroExtend(SRC[127:112] &lt;&lt; COUNT);
FI;
LOGICAL_LEFT_SHIFT_DWORDS1(SRC, COUNT_SRC)
COUNT (cid:197) COUNT_SRC[63:0];
IF (COUNT &gt; 31)
THEN
    DEST[31:0] (cid:197) 0
ELSE
    DEST[31:0] (cid:197) ZeroExtend(SRC[31:0] &lt;&lt; COUNT);
FI;
LOGICAL_LEFT_SHIFT_DWORDS(SRC, COUNT_SRC)
COUNT (cid:197)COUNT_SRC[63:0];
IF (COUNT &gt; 31)
THEN
    DEST[127:0] (cid:197)00000000000000000000000000000000H
ELSE
    DEST[31:0] (cid:197)ZeroExtend(SRC[31:0] &lt;&lt; COUNT);
    (* Repeat shift operation for 2nd through 3rd words *)
    DEST[127:96] (cid:197)ZeroExtend(SRC[127:96] &lt;&lt; COUNT);
FI;
LOGICAL_LEFT_SHIFT_QWORDS1(SRC, COUNT_SRC)
COUNT (cid:197) COUNT_SRC[63:0];
IF (COUNT &gt; 63)
THEN
    DEST[63:0] (cid:197) 0
ELSE
    DEST[63:0] (cid:197) ZeroExtend(SRC[63:0] &lt;&lt; COUNT);
FI;
LOGICAL_LEFT_SHIFT_QWORDS(SRC, COUNT_SRC)
COUNT (cid:197)COUNT_SRC[63:0];
IF (COUNT &gt; 63)
THEN
    DEST[127:0] (cid:197)00000000000000000000000000000000H
ELSE
    DEST[63:0] (cid:197)ZeroExtend(SRC[63:0] &lt;&lt; COUNT);
    DEST[127:64] (cid:197)ZeroExtend(SRC[127:64] &lt;&lt; COUNT);
FI;
LOGICAL_LEFT_SHIFT_WORDS_256b(SRC, COUNT_SRC)
COUNT (cid:197)COUNT_SRC[63:0];
IF (COUNT &gt; 15)
THEN
    DEST[127:0] (cid:197)00000000000000000000000000000000H
    DEST[255:128] (cid:197)00000000000000000000000000000000H
ELSE
    DEST[15:0] (cid:197)ZeroExtend(SRC[15:0] &lt;&lt; COUNT);
    (* Repeat shift operation for 2nd through 15th words *)
    DEST[255:240] (cid:197)ZeroExtend(SRC[255:240] &lt;&lt; COUNT);
FI;
LOGICAL_LEFT_SHIFT_DWORDS_256b(SRC, COUNT_SRC)
COUNT (cid:197)COUNT_SRC[63:0];
IF (COUNT &gt; 31)
THEN
    DEST[127:0] (cid:197)00000000000000000000000000000000H
    DEST[255:128] (cid:197)00000000000000000000000000000000H
ELSE
    DEST[31:0] (cid:197)ZeroExtend(SRC[31:0] &lt;&lt; COUNT);
    (* Repeat shift operation for 2nd through 7th words *)
    DEST[255:224] (cid:197)ZeroExtend(SRC[255:224] &lt;&lt; COUNT);
FI;
LOGICAL_LEFT_SHIFT_QWORDS_256b(SRC, COUNT_SRC)
COUNT (cid:197)COUNT_SRC[63:0];
IF (COUNT &gt; 63)
THEN
    DEST[127:0] (cid:197)00000000000000000000000000000000H
    DEST[255:128] (cid:197)00000000000000000000000000000000H
ELSE
    DEST[63:0] (cid:197)ZeroExtend(SRC[63:0] &lt;&lt; COUNT);
    DEST[127:64] (cid:197)ZeroExtend(SRC[127:64] &lt;&lt; COUNT)
    DEST[191:128] (cid:197)ZeroExtend(SRC[191:128] &lt;&lt; COUNT);
    DEST[255:192] (cid:197)ZeroExtend(SRC[255:192] &lt;&lt; COUNT);
FI;</pre>
<p><strong>VPSLLW (EVEX versions, xmm/m128)</strong></p>
<pre>(KL, VL) = (8, 128), (16, 256), (32, 512)
IF VL = 128
    TMP_DEST[127:0] (cid:197) LOGICAL_LEFT_SHIFT_WORDS_128b(SRC1[127:0], SRC2)
FI;
IF VL = 256
    TMP_DEST[255:0] (cid:197) LOGICAL_LEFT_SHIFT_WORDS_256b(SRC1[255:0], SRC2)
FI;
IF VL = 512
    TMP_DEST[255:0] (cid:197) LOGICAL_LEFT_SHIFT_WORDS_256b(SRC1[255:0], SRC2)
    TMP_DEST[511:256] (cid:197) LOGICAL_LEFT_SHIFT_WORDS_256b(SRC1[511:256], SRC2)
FI;
FOR j (cid:197) 0 TO KL-1
    i (cid:197) j * 16
    IF k1[j] OR *no writemask*
         THEN DEST[i+15:i] (cid:197) TMP_DEST[i+15:i]
         ELSE
              IF *merging-masking*
                                                         ; merging-masking
                    THEN *DEST[i+15:i] remains unchanged*
                    ELSE *zeroing-masking*
                                                              ; zeroing-masking
                         DEST[i+15:i] = 0
              FI
    FI;
ENDFOR
DEST[MAX_VL-1:VL] (cid:197) 0</pre>
<p><strong>VPSLLW (EVEX versions, imm8)</strong></p>
<pre>(KL, VL) = (8, 128), (16, 256), (32, 512)
IF VL = 128
    TMP_DEST[127:0] (cid:197) LOGICAL_LEFT_SHIFT_WORDS_128b(SRC1[127:0], imm8)
FI;
IF VL = 256
    TMP_DEST[255:0] (cid:197) LOGICAL_RIGHT_SHIFT_WORDS_256b(SRC1[255:0], imm8)
FI;
IF VL = 512
    TMP_DEST[255:0] (cid:197) LOGICAL_LEFT_SHIFT_WORDS_256b(SRC1[255:0], imm8)
    TMP_DEST[511:256] (cid:197) LOGICAL_LEFT_SHIFT_WORDS_256b(SRC1[511:256], imm8)
FI;
FOR j (cid:197) 0 TO KL-1
    i (cid:197) j * 16
    IF k1[j] OR *no writemask*
         THEN DEST[i+15:i] (cid:197) TMP_DEST[i+15:i]
         ELSE
              IF *merging-masking*
                                                         ; merging-masking
                    THEN *DEST[i+15:i] remains unchanged*
                    ELSE *zeroing-masking*
                                                              ; zeroing-masking
                         DEST[i+15:i] = 0
              FI
    FI;
ENDFOR
DEST[MAX_VL-1:VL] (cid:197) 0</pre>
<p><strong>VPSLLW (ymm, ymm, xmm/m128) - VEX.256 encoding</strong></p>
<pre>DEST[255:0] (cid:197)LOGICAL_LEFT_SHIFT_WORDS_256b(SRC1, SRC2)
DEST[MAX_VL-1:256] (cid:197)0;</pre>
<p><strong>VPSLLW (ymm, imm8) - VEX.256 encoding</strong></p>
<pre>DEST[255:0] (cid:197)LOGICAL_LEFT_SHIFT_WORD_256b(SRC1, imm8)
DEST[MAX_VL-1:256] (cid:197)0;</pre>
<p><strong>VPSLLW (xmm, xmm, xmm/m128) - VEX.128 encoding</strong></p>
<pre>DEST[127:0] (cid:197)LOGICAL_LEFT_SHIFT_WORDS(SRC1, SRC2)
DEST[MAX_VL-1:128] (cid:197)0</pre>
<p><strong>VPSLLW (xmm, imm8) - VEX.128 encoding</strong></p>
<pre>DEST[127:0] (cid:197)LOGICAL_LEFT_SHIFT_WORDS(SRC1, imm8)
DEST[MAX_VL-1:128] (cid:197)0</pre>
<p><strong>PSLLW (xmm, xmm, xmm/m128)</strong></p>
<pre>DEST[127:0] (cid:197)LOGICAL_LEFT_SHIFT_WORDS(DEST, SRC)
DEST[MAX_VL-1:128] (Unmodified)</pre>
<p><strong>PSLLW (xmm, imm8)</strong></p>
<pre>DEST[127:0] (cid:197)LOGICAL_LEFT_SHIFT_WORDS(DEST, imm8)
DEST[MAX_VL-1:128] (Unmodified)</pre>
<p><strong>VPSLLD (EVEX versions, imm8)</strong></p>
<pre>(KL, VL) = (4, 128), (8, 256), (16, 512)
FOR j (cid:197) 0 TO KL-1
    i (cid:197) j * 32
    IF k1[j] OR *no writemask* THEN
              IF (EVEX.b = 1) AND (SRC1 *is memory*)
                    THEN DEST[i+31:i] (cid:197) LOGICAL_LEFT_SHIFT_DWORDS1(SRC1[31:0], imm8)
                    ELSE DEST[i+31:i] (cid:197) LOGICAL_LEFT_SHIFT_DWORDS1(SRC1[i+31:i], imm8)
              FI;
         ELSE
              IF *merging-masking*
                                                         ; merging-masking
                    THEN *DEST[i+31:i] remains unchanged*
                    ELSE *zeroing-masking*
                                                              ; zeroing-masking
                         DEST[i+31:i] (cid:197) 0
              FI
    FI;
ENDFOR
DEST[MAX_VL-1:VL] (cid:197) 0</pre>
<p><strong>VPSLLD (EVEX versions, xmm/m128)</strong></p>
<pre>(KL, VL) = (4, 128), (8, 256), (16, 512)
IF VL = 128
    TMP_DEST[127:0] (cid:197) LOGICAL_LEFT_SHIFT_DWORDS_128b(SRC1[127:0], SRC2)
FI;
IF VL = 256
    TMP_DEST[255:0] (cid:197) LOGICAL_LEFT_SHIFT_DWORDS_256b(SRC1[255:0], SRC2)
FI;
IF VL = 512
    TMP_DEST[255:0] (cid:197) LOGICAL_LEFT_SHIFT_DWORDS_256b(SRC1[255:0], SRC2)
    TMP_DEST[511:256] (cid:197) LOGICAL_LEFT_SHIFT_DWORDS_256b(SRC1[511:256], SRC2)
FI;
FOR j (cid:197) 0 TO KL-1
    i (cid:197) j * 32
    IF k1[j] OR *no writemask*
         THEN DEST[i+31:i] (cid:197) TMP_DEST[i+31:i]
         ELSE
              IF *merging-masking*
                                                         ; merging-masking
                    THEN *DEST[i+31:i] remains unchanged*
                    ELSE *zeroing-masking*
                                                              ; zeroing-masking
                         DEST[i+31:i] (cid:197) 0
              FI
    FI;
ENDFOR
DEST[MAX_VL-1:VL] (cid:197) 0</pre>
<p><strong>VPSLLD (ymm, ymm, xmm/m128) - VEX.256 encoding</strong></p>
<pre>DEST[255:0] (cid:197)LOGICAL_LEFT_SHIFT_DWORDS_256b(SRC1, SRC2)
DEST[MAX_VL-1:256] (cid:197)0;</pre>
<p><strong>VPSLLD (ymm, imm8) - VEX.256 encoding</strong></p>
<pre>DEST[255:0] (cid:197)LOGICAL_LEFT_SHIFT_DWORDS_256b(SRC1, imm8)
DEST[MAX_VL-1:256] (cid:197)0;</pre>
<p><strong>VPSLLD (xmm, xmm, xmm/m128) - VEX.128 encoding</strong></p>
<pre>DEST[127:0] (cid:197)LOGICAL_LEFT_SHIFT_DWORDS(SRC1, SRC2)
DEST[MAX_VL-1:128] (cid:197)0</pre>
<p><strong>VPSLLD (xmm, imm8) - VEX.128 encoding</strong></p>
<pre>DEST[127:0] (cid:197)LOGICAL_LEFT_SHIFT_DWORDS(SRC1, imm8)
DEST[MAX_VL-1:128] (cid:197)0</pre>
<p><strong>PSLLD (xmm, xmm, xmm/m128)</strong></p>
<pre>DEST[127:0] (cid:197)LOGICAL_LEFT_SHIFT_DWORDS(DEST, SRC)
DEST[MAX_VL-1:128] (Unmodified)</pre>
<p><strong>PSLLD (xmm, imm8)</strong></p>
<pre>DEST[127:0] (cid:197)LOGICAL_LEFT_SHIFT_DWORDS(DEST, imm8)
DEST[MAX_VL-1:128] (Unmodified)</pre>
<p><strong>VPSLLQ (EVEX versions, imm8)</strong></p>
<pre>(KL, VL) = (2, 128), (4, 256), (8, 512)
FOR j (cid:197) 0 TO KL-1
    i (cid:197) j * 64
    IF k1[j] OR *no writemask* THEN
              IF (EVEX.b = 1) AND (SRC1 *is memory*)
                    THEN DEST[i+63:i] (cid:197) LOGICAL_LEFT_SHIFT_QWORDS1(SRC1[63:0], imm8)
                    ELSE DEST[i+63:i] (cid:197) LOGICAL_LEFT_SHIFT_QWORDS1(SRC1[i+63:i], imm8)
              FI;
         ELSE
              IF *merging-masking*
                                                         ; merging-masking
                    THEN *DEST[i+63:i] remains unchanged*
                    ELSE *zeroing-masking*
                                                              ; zeroing-masking
                         DEST[i+63:i] (cid:197) 0
              FI
    FI;
ENDFOR</pre>
<p><strong>VPSLLQ (EVEX versions, xmm/m128)</strong></p>
<pre>(KL, VL) = (2, 128), (4, 256), (8, 512)
IF VL = 128
    TMP_DEST[127:0] (cid:197) LOGICAL_LEFT_SHIFT_QWORDS_128b(SRC1[127:0], SRC2)
FI;
IF VL = 256
    TMP_DEST[255:0] (cid:197) LOGICAL_LEFT_SHIFT_QWORDS_256b(SRC1[255:0], SRC2)
FI;
IF VL = 512
    TMP_DEST[255:0] (cid:197)LOGICAL_LEFT_SHIFT_QWORDS_256b(SRC1[255:0], SRC2)
    TMP_DEST[511:256] (cid:197)LOGICAL_LEFT_SHIFT_QWORDS_256b(SRC1[511:256], SRC2)
FI;
FOR j (cid:197) 0 TO KL-1
    i (cid:197) j * 64
    IF k1[j] OR *no writemask*
         THEN DEST[i+63:i] (cid:197) TMP_DEST[i+63:i]
         ELSE
              IF *merging-masking*
                                                         ; merging-masking
                    THEN *DEST[i+63:i] remains unchanged*
                    ELSE *zeroing-masking*
                                                              ; zeroing-masking
                         DEST[i+63:i] (cid:197) 0
              FI
    FI;
ENDFOR
DEST[MAX_VL-1:VL] (cid:197)0</pre>
<p><strong>VPSLLQ (ymm, ymm, xmm/m128) - VEX.256 encoding</strong></p>
<pre>DEST[255:0] (cid:197)LOGICAL_LEFT_SHIFT_QWORDS_256b(SRC1, SRC2)
DEST[MAX_VL-1:256] (cid:197)0;
VPSLLQ (ymm, imm8) - VEX.256 encoding
DEST[255:0] (cid:197)LOGICAL_LEFT_SHIFT_QWORDS_256b(SRC1, imm8)
DEST[MAX_VL-1:256] (cid:197)0;</pre>
<p><strong>VPSLLQ (xmm, xmm, xmm/m128) - VEX.128 encoding</strong></p>
<pre>DEST[127:0] (cid:197)LOGICAL_LEFT_SHIFT_QWORDS(SRC1, SRC2)
DEST[MAX_VL-1:128] (cid:197)0</pre>
<p><strong>VPSLLQ (xmm, imm8) - VEX.128 encoding</strong></p>
<pre>DEST[127:0] (cid:197)LOGICAL_LEFT_SHIFT_QWORDS(SRC1, imm8)
DEST[MAX_VL-1:128] (cid:197)0</pre>
<p><strong>PSLLQ (xmm, xmm, xmm/m128)</strong></p>
<pre>DEST[127:0] (cid:197)LOGICAL_LEFT_SHIFT_QWORDS(DEST, SRC)
DEST[MAX_VL-1:128] (Unmodified)</pre>
<p><strong>PSLLQ (xmm, imm8)</strong></p>
<pre>DEST[127:0] (cid:197)LOGICAL_LEFT_SHIFT_QWORDS(DEST, imm8)
DEST[MAX_VL-1:128] (Unmodified)</pre>
<h2>Intel C/C++ Compiler Intrinsic Equivalents</h2>
<p>VPSLLD __m512i _mm512_slli_epi32(__m512i a, unsigned int imm);</p>
<p>VPSLLD __m512i _mm512_mask_slli_epi32(__m512i s, __mmask16 k, __m512i a, unsigned int imm);</p>
<p>VPSLLD __m512i _mm512_maskz_slli_epi32( __mmask16 k, __m512i a, unsigned int imm);</p>
<p>VPSLLD __m256i _mm256_mask_slli_epi32(__m256i s, __mmask8 k, __m256i a, unsigned int imm);</p>
<p>VPSLLD __m256i _mm256_maskz_slli_epi32( __mmask8 k, __m256i a, unsigned int imm);</p>
<p>VPSLLD __m128i _mm_mask_slli_epi32(__m128i s, __mmask8 k, __m128i a, unsigned int imm);</p>
<p>VPSLLD __m128i _mm_maskz_slli_epi32( __mmask8 k, __m128i a, unsigned int imm);</p>
<p>VPSLLD __m512i _mm512_sll_epi32(__m512i a, __m128i cnt);</p>
<p>VPSLLD __m512i _mm512_mask_sll_epi32(__m512i s, __mmask16 k, __m512i a, __m128i cnt);</p>
<p>VPSLLD __m512i _mm512_maskz_sll_epi32( __mmask16 k, __m512i a, __m128i cnt);</p>
<p>VPSLLD __m256i _mm256_mask_sll_epi32(__m256i s, __mmask8 k, __m256i a, __m128i cnt);</p>
<p>VPSLLD __m256i _mm256_maskz_sll_epi32( __mmask8 k, __m256i a, __m128i cnt);</p>
<p>VPSLLD __m128i _mm_mask_sll_epi32(__m128i s, __mmask8 k, __m128i a, __m128i cnt);</p>
<p>VPSLLD __m128i _mm_maskz_sll_epi32( __mmask8 k, __m128i a, __m128i cnt);</p>
<p>VPSLLQ __m512i _mm512_mask_slli_epi64(__m512i a, unsigned int imm);</p>
<p>VPSLLQ __m512i _mm512_mask_slli_epi64(__m512i s, __mmask8 k, __m512i a, unsigned int imm);</p>
<p>VPSLLQ __m512i _mm512_maskz_slli_epi64( __mmask8 k, __m512i a, unsigned int imm);</p>
<p>VPSLLQ __m256i _mm256_mask_slli_epi64(__m256i s, __mmask8 k, __m256i a, unsigned int imm);</p>
<p>VPSLLQ __m256i _mm256_maskz_slli_epi64( __mmask8 k, __m256i a, unsigned int imm);</p>
<p>VPSLLQ __m128i _mm_mask_slli_epi64(__m128i s, __mmask8 k, __m128i a, unsigned int imm);</p>
<p>VPSLLQ __m128i _mm_maskz_slli_epi64( __mmask8 k, __m128i a, unsigned int imm);</p>
<p>VPSLLQ __m512i _mm512_mask_sll_epi64(__m512i a, __m128i cnt);</p>
<p>VPSLLQ __m512i _mm512_mask_sll_epi64(__m512i s, __mmask8 k, __m512i a, __m128i cnt);</p>
<p>VPSLLQ __m512i _mm512_maskz_sll_epi64( __mmask8 k, __m512i a, __m128i cnt);</p>
<p>VPSLLQ __m256i _mm256_mask_sll_epi64(__m256i s, __mmask8 k, __m256i a, __m128i cnt);</p>
<p>VPSLLQ __m256i _mm256_maskz_sll_epi64( __mmask8 k, __m256i a, __m128i cnt);</p>
<p>VPSLLQ __m128i _mm_mask_sll_epi64(__m128i s, __mmask8 k, __m128i a, __m128i cnt);</p>
<p>VPSLLQ __m128i _mm_maskz_sll_epi64( __mmask8 k, __m128i a, __m128i cnt);</p>
<p>VPSLLW __m512i _mm512_slli_epi16(__m512i a, unsigned int imm);</p>
<p>VPSLLW __m512i _mm512_mask_slli_epi16(__m512i s, __mmask32 k, __m512i a, unsigned int imm);</p>
<p>VPSLLW __m512i _mm512_maskz_slli_epi16( __mmask32 k, __m512i a, unsigned int imm);</p>
<p>VPSLLW __m256i _mm256_mask_sllii_epi16(__m256i s, __mmask16 k, __m256i a, unsigned int imm);</p>
<p>VPSLLW __m256i _mm256_maskz_slli_epi16( __mmask16 k, __m256i a, unsigned int imm);</p>
<p>VPSLLW __m128i _mm_mask_slli_epi16(__m128i s, __mmask8 k, __m128i a, unsigned int imm);</p>
<p>VPSLLW __m128i _mm_maskz_slli_epi16( __mmask8 k, __m128i a, unsigned int imm);</p>
<p>VPSLLW __m512i _mm512_sll_epi16(__m512i a, __m128i cnt);</p>
<p>VPSLLW __m512i _mm512_mask_sll_epi16(__m512i s, __mmask32 k, __m512i a, __m128i cnt);</p>
<p>VPSLLW __m512i _mm512_maskz_sll_epi16( __mmask32 k, __m512i a, __m128i cnt);</p>
<p>VPSLLW __m256i _mm256_mask_sll_epi16(__m256i s, __mmask16 k, __m256i a, __m128i cnt);</p>
<p>VPSLLW __m256i _mm256_maskz_sll_epi16( __mmask16 k, __m256i a, __m128i cnt);</p>
<p>VPSLLW __m128i _mm_mask_sll_epi16(__m128i s, __mmask8 k, __m128i a, __m128i cnt);</p>
<p>VPSLLW __m128i _mm_maskz_sll_epi16( __mmask8 k, __m128i a, __m128i cnt);</p>
<p>PSLLW:__m64 _mm_slli_pi16 (__m64 m, int count)</p>
<p>PSLLW:__m64 _mm_sll_pi16(__m64 m, __m64 count)</p>
<p>(V)PSLLW:__m128i _mm_slli_pi16(__m64 m, int count)</p>
<p>(V)PSLLW:__m128i _mm_slli_pi16(__m128i m, __m128i count)</p>
<p>VPSLLW:__m256i _mm256_slli_epi16 (__m256i m, int count)</p>
<p>VPSLLW:__m256i _mm256_sll_epi16 (__m256i m, __m128i count)</p>
<p>PSLLD:__m64 _mm_slli_pi32(__m64 m, int  count)</p>
<p>PSLLD:__m64 _mm_sll_pi32(__m64 m, __m64 count)</p>
<p>(V)PSLLD:__m128i _mm_slli_epi32(__m128i m, int  count)</p>
<p>(V)PSLLD:__m128i _mm_sll_epi32(__m128i m, __m128i count)</p>
<p>VPSLLD:__m256i _mm256_slli_epi32 (__m256i m, int count)</p>
<p>VPSLLD:__m256i _mm256_sll_epi32 (__m256i m, __m128i count)</p>
<p>PSLLQ:__m64 _mm_slli_si64(__m64 m, int  count)</p>
<p>PSLLQ:__m64 _mm_sll_si64(__m64 m, __m64 count)</p>
<p>(V)PSLLQ:__m128i _mm_slli_epi64(__m128i m, int  count)</p>
<p>(V)PSLLQ:__m128i _mm_sll_epi64(__m128i m, __m128i count)</p>
<p>VPSLLQ:__m256i _mm256_slli_epi64 (__m256i m, int count)</p>
<p>VPSLLQ:__m256i _mm256_sll_epi64 (__m256i m, __m128i count)</p>
<h2>Flags Affected</h2>
<p>None.</p>
<h2>Numeric Exceptions</h2>
<p>None.</p>
<h2>Other Exceptions</h2>
<table class="exception-table">
<tr>
<td>VEX-encoded instructions:</td></tr>
<tr>
<td>Syntax with RM/RVM operand encoding, see Exceptions Type 4.</td></tr>
<tr>
<td>Syntax with MI/VMI operand encoding, see Exceptions Type 7.</td></tr>
<tr>
<td>EVEX-encoded VPSLLW, see Exceptions Type E4NF.nb.</td></tr>
<tr>
<td>EVEX-encoded VPSLLD/Q:</td></tr>
<tr>
<td>Syntax with M128 operand encoding, see Exceptions Type E4NF.nb.</td></tr>
<tr>
<td>Syntax with FVI operand encoding, see Exceptions Type E4.</td></tr></table></body></html>